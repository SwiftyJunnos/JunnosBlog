# 🍎 Swift - Regex.01

아는 사람들은 잘 써먹는 그것.

@Metadata {
  @PageKind(article)
  @PageColor(orange)
}

##

정규표현식 참 애증의 개념인 것 같습니다.
저는 잘 몰라서 못쓰는데, 잘 쓰는 사람들은 20줄~30줄이 필요한 코드를 단 한 줄로 처리해버리거든요.

그래서 미루고 미루다 드디어 저도 이게 뭔지나 한 번 보자는 식으로 공부해보기로 했습니다.

## 정규표현식 (Regular Expression) 

흔히 **"Regex"** 라고 많이들 줄여서 부르는데요..

**Reg**ular **Ex**pression의 줄임말입니다.

정규표현식이란 어떤 문자를 처리하기 위한 규칙들을 정해둔 문법입니다.
ex) 문자열에 숫자가 있는지, 문자열에 "s"로 시작하는 단어가 있는지

문자열에 어떤 패턴을 묻고, 그 패턴을 충족하는지?에 대한 답변을 얻을 수 있는 것이죠.

## 주어진 문자열 찾기

가장 쉬운 예제부터 시작해봅시다.

아무런 기호 없이 사용했을 경우, 정확히 주어진 문자가 포함되어 있는 지를 확인할 수 있습니다.

> Source:
>
> Hello, world!

### 대소문자 구분

`Hello`

matches: ***Hello***, world!

`hello`

matches: Hello, world!

정규식은 **대소문자 구분**을 합니다. 그래서 "hello"와 "Hello"는 다른 문자로 판단되는 것이죠.

### whitespace 구분

`Hello, world`

matches: ***Hello, world***!

`Hello,` &nbsp; &nbsp; &nbsp;`world`

matches: Hello, world!

정규식은 **whitespace(빈 공간)도 구분**을 합니다. 그래서 "Hello, world"와 "Hello,   world"는 다른 문자인 것이죠.

## 문자열의 위치 찾기

찾고자 하는 문자열의 위치를 제약해서 찾아낼 수도 있습니다.

> Source:
> 
> who is who

### `^`, `$`

`^who`

matches: **who** is who

`^`은 시작되는 부분이 조건일 때 충족합니다.

`who$`

matches: who is **who**

반대로 `$`는 끝나는 부분이 조건일 때 충족합니다.

> Notes:
>
> 문자열에 조건 기호가 포함될 때는 어떻게 할까요? ($440과 같이)
>
> 그럴 때는 `\`를 사용합니다. `\`는 `\` 뒤에 있는 문자를 기호가 아닌 문자열이라는 것을 의미합니다. (`\$`)

## 문자의 유무 판단하기

> Source:
>
> Regular expressions are powerful!!!

### `.`

`.`

first match: ***R***egular expressions are powerful!!!

matches: ***Regular expressions are powerful!!!***

`.`은 어떤 문자던 존재하면 충족하는 일종의 와일드카드 입니다.

`......`

first match: ***Regula***r expressions are powerful!!!

matches: ***Regular expressions are powerf***ul!!!

여러 개를 사용해서 원하는 문자의 개수를 조건으로 줄 수 있습니다.

matches에서 맨 끝의 "ul!!!"이 선택되지 못한 것은 앞에서부터 6개씩의 문자를 찾을 때, 맨 뒤의 5개 문자가 남기 때문입니다.

## 원하는 특정 문자들 중에서 찾아내기

모든 문자 말고, 내가 원하는 특정 문자가 있다면 어떻게 할까요?

### `[]`

> Source:
>
> How do you do?

`[oyu]`

first match: H***o***w do you do?

matches: H***o***w d***o*** ***you*** d***o***?

대괄호에 내가 원하는 문자의 종류를 넣어줌으로써 특정 문자들만 찾아낼 수 있습니다.

`[dH].`

first match: ***Ho***w do you do?

matches: ***Ho***w ***do*** you ***do***?

이 때 주의할 점은, `[]`안의 종류가 얼마나 많던지 문자 **"하나"**를 의미한다는 점입니다.

그래서 예시의 `[dH].`는 d혹은 H가 포함된 한글자와 그 뒤에 따라붙는 아무 문자 한글자를 찾아내는 정규식인거죠.

### `[-]`

> Source:
>
> ABCDEFGHIJKLMNOPQRSTUVWXYZ

그런데 조건으로 넣을 문자가 너~무 많을 떄는 어떻게 하면 될까요?

`[CDEFGHIJK]` 처럼 일일히 넣어줘도 되지만, `-`를 사용해 범위를 표현할 수도 있습니다.

`[C-K]`

first match: AB***C***DEFGHIJKLMNOPQRSTUVWXYZ

matches: AB***CDEFGHIJK***LMNOPQRSTUVWXYZ

`[C-Ka-d2-6]`

> Source:
>
> ABCDEFGHIJKLMNOPQRSTUVWXYZ
> abcdefghijklmnopqrstuvwxyz 123456789

first match: AB***C***DEFGHJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 123456789

matches: AB***CDEFGHIJK***LMNOPQRSTUVWXYZ ***abcd***efghijklmnopqrstuvwxyz 1***23456***789

### `[^]`

친숙한 `^`가 왔네요. 그럼 `[^]`는 주어진 범위의 문자들 중 하나로 시작되는 조건일까요?

아쉽게도 아닙니다. `^`가 대괄호 안에 왔을 때는, *NOT*의 의미로 사용됩니다.

> Source:
>
> ABCDEFGHIJKLMNOPQRSTUVWXYZ

`[^CD]`

firstm match: ***A***BCDEFGHIJKLMNOPQRSTUVWXYZ

matches: ***AB***CD***EFGHIJKLMNOPQRSTUVWXYZ***

`^`로 표현된 "CD"만 선택에서 제외된 것을 볼 수 있죠?

## 서브패턴

동시에 여러개의 조건을 주고싶을 때는 어떻게 할까요?

`|`를 사용해주면 됩니다!

> Source:
>
> Monday Tuesday Friday

### `|`

`(on|ues|rida)`

first match: M***on***day Tuesday Friday

matches: M***on***day T***ues***day F***rida***y

이렇게 여러개의 조건들을 한 번에 줄 수 있습니다. 대신 괄호로 묶어주어야 한다는 점은 기억해둬야겠네요!

`(Mon|Tues|Fri)day`

matches: ***Monday Tuesday Friday***

## 발생할 수 있는 문자의 횟수 정해주기

주어진 문자가 몇 번 등장할 수 있는지를 정할수도 있습니다.

문자가 최소 3번에서 최대 6번까지 등장한 문자를 찾아줘! 와 같은 경우에 사용할 수 있겠죠?

### `*`, `+`, `?`

> Source:
>
> aabc abc bc

`a*b`

first match: ***aab***c abc bc

matches: ***aab***c ***ab***c ***b***c

`*`는 앞의 문자가 0회 혹은 여러개가 올 수 있음을 의미합니다.

그래서 예시는 a가 있으면 모든 a들을 포함하고, 그 뒤에 b가 하나 와야하는 조건이겠죠?

`a+b`

first match: ***aab***c abc bc

matches: ***aab***c ***ab***c bc

`+`는 앞의 문자가 1회 혹은 여러개가 올 수 있음을 의미합니다. `*`와 다른 점은 최소 한 번은 있어야 한다는 것이죠!

그래서 예시의 "bc"는 조건에서 제외되어 있다는 것을 알 수 있네요.

`a?b`

first match: a***ab***c abc bc

matches: a***ab***c ***ab***c ***b***c

`?`는 앞의 문자가 0회 혹은 한 번 올 수 있음을 의미합니다.

`[-@]*`

> Source:
>
> -@- *** -- "*" -- *** -@-

first match: ***-@-*** \*\*\* -- "\*" -- \*\*\* -@-

matches: <span style="background-color:#fff5b1"> -@- </span> \*\*\* ***--*** "\*" ***--*** \*\*\* ***-@-*** 
